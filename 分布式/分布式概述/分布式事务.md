# 分布式事务

一个事务中涉及到多个数据库。主要有三类：
1. 跨库事务：事务包含多个数据库。
2. 分库分表：一个数据库分成多个部分。
3. SOA架构：跨应用。
SOA：Service-Oriented Architecture，面向服务的架构，是一个组件模型，它将应用程序的不同功能单元（称为服务）进行拆分，并通过这些服务之间定义良好的接口和契约联系起来。接口是采用中立的方式进行定义的，它应该独立于实现服务的硬件平台、操作系统和编程语言。这使得构建在各种各样的系统中的服务可以以一种统一和通用的方式进行交互。
实现分布式事务主要有**四种解决方案**
1. 两阶段提交（2PC）
2. 补偿事务（TCC）
3. 本底消息表（异步确保）
4. MQ事务消息
---- 
## 两阶段提交（2PC/XA）
两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。
![][image-1]
![][image-2]
### 存在问题
1. 同步阻塞
	所有事务参与者在等待其它参与者响应的时候都处于**同步阻塞**状态，无法进行其它操作。
2. 单点问题
	协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。
3. 数据不一致
	在阶段二，如果协调者只发送了部分 Commit 消息，此时**网络发生异常**，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。
4. 太过保守
	任意一个节点失败就会导致整个事务失败，没有完善的**容错机制**。
---- 
## 补偿事务（TCC）
针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：
1. Try 阶段主要是对业务系统做检测及资源预留
2. Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
3. Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
举个例子，假入 Bob 要向 Smith 转账，思路大概是： 我们有一个本地方法，里面依次调用
1. 首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。
2. 在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。
3. 如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。
- 优点：跟2PC比起来，实现以及流程相对**简单**了一些，但数据的**一致性**比2PC也要差一些
- 缺点：缺点还是比较明显的，在2、3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。
---- 
## 本地消息表（Kafka）
本地消息表与业务数据表处于同一个数据库中，这样就能利用**本地事务**来保证在对这两个表的操作满足事务特性，并且使用了消息队列来保证最终一致性。
1. 在分布式事务操作的一方完成写业务数据的操作之后向本地消息表发送一个消息，本地事务能保证这个消息一定会被写入本地消息表中。
	2. 之后将本地消息表中的消息转发到 Kafka 等消息队列中，如果转发成功则将消息从本地消息表中删除，否则继续重新转发。
	3. 在分布式事务操作的另一方从消息队列中读取一个消息，并执行消息中的操作。
![][image-3]
- 优点：一种非常经典的实现，**避免了分布式事务**，实现了最终一致性。
- 缺点：消息表会**耦合**到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。
---- 
## MQ事务消息（RocketMQ）
有一些第三方的MQ是支持事务消息的，比如RocketMQ，他们支持事务消息的方式也是类似于采用的二阶段提交，但是市面上一些主流的MQ都是不支持事务消息的，比如 RabbitMQ 和 Kafka 都不支持。
以阿里的 *RocketMQ* 中间件为例，其思路大致为：
第一阶段Prepared消息，会拿到消息的地址。 第二阶段执行本地事务，第三阶段通过第一阶段拿到的地址去访问消息，并修改状态。
也就是说在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。
![][image-4]
- 优点： 实现了最终一致性，不需要依赖本地数据库事务。
- 缺点： **实现难度大**，主流MQ不支持，RocketMQ事务消息部分代码也未开源。

[image-1]:	https://raw.githubusercontent.com/pengnian95/ImageRepository/master/img/20191005010457.png?token=AJFPGG7WZX2HHL5NZHJRORC5S56AS
[image-2]:	https://raw.githubusercontent.com/pengnian95/ImageRepository/master/img/20191005010544.png?token=AJFPGG7VAGPPI7D6ZM62U6C5S56DU
[image-3]:	https://raw.githubusercontent.com/pengnian95/ImageRepository/master/img/20191005011215.png?token=AJFPGG4XUHZO3QH4FRQQW7S5S564C
[image-4]:	https://raw.githubusercontent.com/pengnian95/ImageRepository/master/img/20191005011231.png?token=AJFPGGZBFRCW57IRKYE6V4K5S5646