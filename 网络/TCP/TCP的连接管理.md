# TCP的连接管理

## 三次握手
![]()
1. 假设 A 为客户端，B 为服务器端。
2. 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 
3. A 向 B 发送连接请求报文，*SYN=1，ACK=0*，选择一个*初始的序号 x*。 
4. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，*SYN=1，ACK=1，确认号为 x+1*，同时也选择一个*初始的序号 y*。 
5. A 收到 B 的连接确认报文后，还要向 B 发出确认，*确认号为 y+1，序号为 x+1*。
6. B收到 A 的确认后，连接建立。

## 三次握手的原因
第三次握手是为了*防止失效的连接请求到达服务器，让服务器错误打开连接*。
客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待 一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握 手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确 认，不进行第三次握手，因此就不会再次打开连接。
---- 
## 四次挥手
![]()
以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 _ACK 在连接建立之后都 为 1_。
1. A 发送连接释放报文，FIN=1。 
2. B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 
3. 当 B 不再需要连接时，发送连接释放报文，FIN=1。
4. A收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 
5. B 收到 A 的确认后释放连接。

## 四次挥手的原因
客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 `CLOSE-WAIT` 状态。这个状态是为了让服 务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。
---
## TIME_WAIT
1. 确保最后一个*确认报文能够到达*。如果B没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 
2. 等待一段时间是为了*让本连接持续时间内所产生的所有报文都从网络中消失*，使得下一个新的连接不会出现旧的连接请求报文。

